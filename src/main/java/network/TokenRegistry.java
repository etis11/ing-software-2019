package network;

import controller.JsonReceiver;
import exceptions.DuplicateException;
import model.User;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public class TokenRegistry {

    /**
     * singleton instance
     */
    private static TokenRegistry registry;


    private final Logger tokenRegistryLogger = Logger.getLogger(TokenRegistry.class.getName());
    /**
     * map where token and json receivers are linked
     */
    private  final ConcurrentMap<String, JsonReceiver> associatonTokenReceiver;
    /**
     * list of all the registered tokens
     */
    private  final List<String> registeredTokens;
    /**
     * map where the json receiver and the user are associated
     */
    private  final ConcurrentMap<JsonReceiver, User> receiverUser;

    private final ConcurrentMap<String, User> tokenToUser;

    private final List<String> userNames;


    private TokenRegistry(){
        associatonTokenReceiver  = new ConcurrentHashMap<>();
        registeredTokens = new ArrayList<>(10);
        receiverUser = new ConcurrentHashMap<>();
        tokenToUser = new ConcurrentHashMap<>();
        userNames = new LinkedList<>();
    }

    /**
     * returns the singleton
     * @return
     */
    public static  TokenRegistry getInstance(){
        if (registry== null) {
            registry= new TokenRegistry();
        }
        return  registry;
    }

    /**
     * True if this token has been already generated by this server
     * @param token token passed by the client
     * @return
     */
    public boolean tokenAlreadyGenerated(String token) {
        return registeredTokens.contains(token);
    }

    /**
     * Tells if the username has been already generated
     * @param name
     * @return true if some other user has already chose this username
     */
    public boolean usernameAlreadyPresent(final String name){
        // TODO prima era solo col primo dell'or, fare dei test per vedere se posso assumere il nome di qualcuno disconnesso.
        return receiverUser.values().stream().anyMatch(user->user.getUsername().equals(name)) ||
                tokenToUser.values().stream().anyMatch(user -> user.getUsername().equals(name));
    }

    /**
     * returns the json receiver associated to this token
     * @param token
     * @return
     */
    public JsonReceiver getJsonReceiver(String token) {
        JsonReceiver receiver = associatonTokenReceiver.get(token);
        if (receiver == null) throw new NullPointerException("This token is not registered");
        return receiver;
    }

    /**
     * Gets the user given it's json receiver
     * @param receiver source receiver
     * @return correspongind user
     */
    public User getJsonUserOwner(JsonReceiver receiver) {
        User owner = receiverUser.get(receiver);
        return owner;
    }

    /**
     * returns the corresponding user of this token
     * @param token key
     * @return user, can be null
     */
    public User getUserFromToken(String token){
        return tokenToUser.get(token);
    }



    /**
     * Adds a token to a token registry. If the token has already sent, is not added, because it's already there. This happens
     * when a client disconnects and reconnects.
     * Then, creates an association between the token and the jsonReceiver of the client.
     * If a token is already associated with a json receiver, this method fails.
     *
     * @param token        token of the client
     * @param jsonReceiver jsonReceiver of the client
     */
    public void associateTokenAndReceiver(String token, JsonReceiver jsonReceiver) {
        synchronized (registeredTokens) {
            if (associatonTokenReceiver.containsKey(token))
                throw new DuplicateException(">>> There is already a jsonReceiver associated to this token");
            if (!registeredTokens.contains(token)) registeredTokens.add(token);
            associatonTokenReceiver.putIfAbsent(token, jsonReceiver);
            tokenRegistryLogger.log(Level.INFO, "Associated token and json receiver");
        }
    }

    /**
     * associates the given json receiver and user. A json receiver can exist while the user is still null
     * @param jr client json receiver
     * @param user user that is associated to this
     */
    public void associateReceiverAndUser(JsonReceiver jr, User user){
        receiverUser.putIfAbsent(jr, user);
        tokenRegistryLogger.log(Level.INFO, "Associated json receiver and user " + user.getUsername());

    }

    /**
     * associated token and user
     * @param token key
     * @param user value
     */
    public void associateTokenAndUser(String token, User user){
        tokenToUser.put(token, user);
        tokenRegistryLogger.log(Level.INFO, "Associated token and user " + user.getUsername());

    }


    /**
     * removes the association between the token and the json receiver. The token is not removed.
     * @param token
     */
    public void removeTokenReceiverAssociation(String token) {
        associatonTokenReceiver.remove(token);
    }


    /**
     * given the json receiver, remove the associaton between the token and the json receiver
     * @param jsonReceiver the json receiver that has to be removed
     */
    public void removeTokenReceiverAssociation(JsonReceiver jsonReceiver){
        synchronized (registeredTokens){
            for(String token: registeredTokens){
                if (associatonTokenReceiver.get(token) == jsonReceiver){
                    associatonTokenReceiver.remove(token, jsonReceiver);
                }
            }
        }
    }

    /**
     * remove both the token and user
     * @param token token of the user that has to be removed
     */
    public void removeTokenToUserAssociation(String token){
        tokenToUser.remove(token);
        tokenRegistryLogger.log(Level.INFO, "Removed token " + token);

    }


    public void removeReceiverUserAssociation(JsonReceiver jsonReceiver){
        receiverUser.remove(jsonReceiver);
    }

    public void removeToken(String token){
        synchronized (registeredTokens){
            registeredTokens.remove(token);
        }
    }


    /**
     * Used in the login phase, creates a momentary association between a token and a fake user
     * @param token
     * @param name
     * @return
     */
    public boolean checkAndInsertUsername(String token, final String name) {
        if (receiverUser.values().stream().anyMatch(user -> user.getUsername().equals(name)))
            return true;
        else {
            tokenToUser.put(token, new User(name));
            return false;
        }
    }

}
